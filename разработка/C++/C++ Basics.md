int - байта
short - 2 байта
char - 1 байт (-128 до 127)

Локальные переменные простых типов, таких как `int`, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять

```C++
char c; инициализация
c = 10; определение

int grades[30]; массив интов (получаем адрес памяти)
*(grades + 20) обращение к 20 элементу в масиве путем смещения и разыменования
можно записать и так grades[20]

Ссылка
- привязана к одному и тому же обьекту, нельзя переназначить
int x = 42;
int& ref = x;

int A = 5;
int* pA = &A;
std::cout << &A; выводим адресс в памяти
std::cout << *pA; операция разыменования берет значение по указаному адресу
*pA = 10; изменяем значение по указаному адресу

Почему у указателя нужно указывать тип?
- для того чтобы считать правильно весь размер в памяти, т.к. сам указатель указывает на начало байтов в памяти

int* array = new int[250]; - выделяем память в куче и сохраняем указатель
delete[] array; - очищение памяти (где int это имя указателя)
```

Функции

```C++
void print(int x, int style = 0) { // style = 0 по умолчанию
  //...
}

void increase_by_one(int* value) {  
    (*value)++;  // увеличиваем на 1 значение лежащее по адресу в памяти 
}

void increase_by_one(int& value) {  
    value++;  // тоже самое но проще писать и работать
}

void increase_by_one_ref(std::string& value) // синтаксис для обозначения что делает функция
void increase_by_one_val(std::string value) 
```

Сборка
.cpp -> .exe

препроцесинг (находит все include и заменяет их текстом в каждом файле .i)
-> компиляция (компилирует единицу трансляции .i в  объектные файлы obj, файлы которые можно быстро скомпоновать в отдельную программу)
-> компоновка / линковка (объединяет объектные файлы в исполняемый файл)
= .exe

Шаблон

```C++
template <class T> max(T num1, T num2) {
	return num1 > num2 ? num1 : num2;
}

template <typename T> max(const T& num1,const T& num2) {
	return num1 > num2 ? num1 : num2;
}
```


namespace
```C++
namespace sheet {  
    void hello() { 
    // ... 
    }  
}

int main() {  
    sheet::hello();
    return 0;  
}
```

Последовательные контейнеры
```C++
std::array<int, 3> point = {1, 2, 3};
```
- как и у вектора элементы располагаются в памяти непрерывно, но хранятся не в динамической памяти а на стеке

```C++
std::deque<int> point = {1, 2, 3};
point.push_back(5);
point.pop_back();
```
- располагает элементы кусочно-непрерывно, в отдельных страницах памяти фиксированного размера

```C++
std::list<int> point = {1, 2, 3};
point.push_back(5);
point.pop_back();
```
- элементы располагаются в разных местах памяти

```C++
int main() {|
std::list<int> l = {10, 15, 20};
// Используем auto, чтобы не писать громоздкий тип std::list<int>::iterator|
auto iter = l.begin();
std::cout << *iter << "\n"; // печатаем начальный элемент|
++iter; // сдвигаемся к следующему элементу|
--iter; // возвращаемся назад|
}
```
Итераторы в C++ создавались по подобию указателей: их можно разыменовывать (`*`) и сдвигать (`++` и `--`). Однако операторы `++` и `--` для обычных указателей сдвигаются на соседние ячейки памяти, а двусвязный список хранит свои элементы разрозненно. Поэтому указатели могут подойти на роль итераторов лишь для контейнеров с непрерывным хранением (`array`, `vector` и `string`).

```C++
std::map<std::string, int> years = {
	{"Moscow", 1147},
};

for (const auto& [city, year] : years) {
	...
}
```