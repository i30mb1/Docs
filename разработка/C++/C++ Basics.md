int - байта
short - 2 байта
char - 1 байт (-128 до 127)

```C++
char c; инициализация
c = 10; определение

int grades[30]; массив интов (получаем адрес памяти)
*(grades + 20) обращение к 20 элементу в масиве путем смещения и разыменования
можно записать и так grades[20]

int A = 5;
int* pA = &A;
std::cout << &A; выводим адресс в памяти
std::cout << *pA; операция разыменования берет значение по указаному адресу
*pA = 10; изменяем значение по указаному адресу

Почему у указателя нужно указывать тип?
- для того чтобы считать правильно весь размер в памяти, т.к. сам указатель указывает на начало байтов в памяти

int* array = new int[250]; - выделяем память в куче и сохраняем указатель
delete[] array; - очищение памяти (где int это имя указателя)
```

Функции

```C++
void print(int x, int style = 0) { // style = 0 по умолчанию
  //...
}

void increase_by_one(int* value) {  
    (*value)++;  // увеличиваем на 1 значение лежащее по адресу в памяти 
}

void increase_by_one(int& value) {  
    value++;  // тоже самое но проще писать и работать
}

void increase_by_one_ref(std::string& value) // синтаксис для обозначения что делает функция
void increase_by_one_val(std::string value) 
```

Сборка
.cpp -> .exe

препроцесинг (находит все include и заменяет их текстом в каждом файле .i)
-> компиляция (компилирует единицу трансляции .i в  объектные файлы obj, файлы которые можно быстро скомпоновать в отдельную программу)
-> компоновка / линковка (объединяет объектные файлы в исполняемый файл)
= .exe

Шаблон

```C++
template <class T> max(T num1, T num2) {
	return num1 > num2 ? num1 : num2;
}
```

Структура (поля публичные по умолчанию) == Класс (поля приватные по умолчанию)
```C++
struct Enemy {  
    int x;  
    int y;  
};

int main() {  
    Enemy ghost;  
    ghost.x = 5; 
    return 0;  
}
```

namespace
```C++
namespace sheet {  
    void hello() { 
    // ... 
    }  
}

int main() {  
    sheet::hello();
    return 0;  
}
```