позволяет определять, на каком потоке должны выполняться операции

### CoroutineScope

интерфейс который определяет время жизни и контекст корутины. Он отвечает за управление жизненным циклом корутин, включая их отмену и обработку ошибок

### CoroutineContext

нужен для хранения полезных штук при выполнении корутины:
CoroutineName, CoroutineDispatcher, Job, CoroutineExceptionHandler...

https://habr.com/ru/articles/827866/
### GlobalScope

это глобальный CoroutineScope, который может быть использован для запуска корутин в приложении. Он не связан с жизненным циклом компонентов
Android и продолжает выполнение корутин, даже если активность или фрагмент были уничтожены.

```
GlobalScope.launch { // Код корутины }
```

Однако использование GlobalScope не рекомендуется в большинстве случаев. Вот несколько причин
**1. Отсутствие контроля жизненного цикла.**
**2. Затруднение в тестировании.**

### Dispatchers

**Dispatchers.Main**— это диспетчер, который используется для выполнения корутин в главном потоке Android. Он должен применяться для всех
операций, которые изменяют пользовательский интерфейс, таких как обновление View, Toast и т.д.

**Dispatchers.IO**— диспетчер, который используется для ввода-вывода (I/O) операций, таких как чтение или запись файлов, сетевые операции и
т.д. Он также имеет доступ к пулу потоков с несколькими потоками.

**Dispatchers.Default**— это диспетчер, который используется по умолчанию. Он предназначен для выполнения вычислительных задач и имеет
доступ к пулу потоков с несколькими потоками. Если вы не указываете явно диспетчер для корутины, она будет выполнена на диспетчере Default.

**Dispatchers.Unconfined**— это диспетчер, который не ограничивает выполнение корутины каким-либо конкретным потоком. Корутина будет
продолжена на том же потоке, на котором была запущена. Этот диспетчер должен использоваться только в очень ограниченном числе случаев, когда
корутина может быть запущена и продолжена на любом потоке

Под капотом диспетчеры работают на основе пула потоков. Пул потоков представляет собой набор заранее созданных потоков, которые могут быть
повторно использованы для выполнения задач

https://habr.com/ru/articles/747858/
- при отмене scope любая suspend функция выкидывает CancelationException
- CoroutineExceptionHandler работает только у самого верхнего родителя
- Конструкция **coroutineScope** внутри которой можно запускать несколько корутин, которые будут работать параллельно и все они должны завершиться чтобы **coroutineScope** блок вернул результат выполнения
```Kotlin
coroutineScope == withContext(this.coroutineContext)
```
Для того чтобы запустить работу и ее не дожидались нужно поменять Job
```Kotlin
coroutineScope {  
	launch(Job()) { ... }  
}
```
или 
```Kotlin
withContext(NonCancalable) { ...
```
или запустить в другом CoroutineScope
- ошибки внутри coroutineScope можно отловить вот атк
```Kotlin
try {
  coroutineScope { ...
} catch { ...
```
- superviserJob не прокидывает ошибку приложению а только печатает ее
- если обычная джоба завершится с ошибкой то все остальные джобы перестанул выполнятся
- Передавать scope плохо, если из-вне отменят scope то при run не будет ни ошибки, ни выполнится работа
```Kotlin
class Work(private val scope: CoroutineScope) {  
  
	fun run() {  
		scope.launch {  
		delay(1_000)  
		println("work done")  
			 }  
		  }  
}
```

https://www.droidcon.com/2023/10/06/coroutines-flow-android-the-good-parts/